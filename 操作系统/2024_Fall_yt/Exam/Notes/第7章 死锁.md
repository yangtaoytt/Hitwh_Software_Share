### 第7章 死锁

[TOC]

#### 1. 什么时候可能发生死锁？
1. 进程**占用**一个资源。
2. **请求**被其他进程所占用的资源。

#### 2. 进程使用资源顺序
1. **申请**。
2. **使用**。
3. **释放**。

#### 3. 死锁定义
当一组进程中的每个进程都在**等待一个事件的发生**，而这一事件只能由这**一组进程中的进程**引起，那么这组进程就处于死锁状态。

#### 4. 死锁特征/必要条件

1. **互斥条件（互斥）**：一个资源只能由一个进程占用。
2. **请求和保持条件（占用并等待）**：一个进程必须占用一个资源，并请求/等待另一个资源。
3. **不剥夺条件（非抢占）**：资源不能被抢占。
4. **循环等待条件（循环等待）**：有一组等待进程 {P0, P1, …, Pn}，P0等待的资源被P1所占用，P1等待的资源被P2占用，…，Pn等待的资源被P0所占用。

#### 5. 死锁和环的关系
1. 如果分配图**没有环**，就**没有死锁**。
2. 如果分配图**有环**，就**可能发生死锁**，分情况讨论：
   - 如果每个资源类型只有**一个实例**，就肯定会发生死锁。
   - 如果每个资源类型有**多个实例**，就可能处于死锁。

#### 6. 预防/避免死锁的概念
1. **预防死锁**：确保至少一个**必要条件不成立**。
2. **避免死锁**：利用事先得到的进程申请资源和使用资源的**额外信息**，**判断**每当发生资源请求时**是否会发生死锁**。

#### 7. 检测与恢复死锁的概念
1. 确定死锁是**否确实发生**。
2. 提供算法**从死锁中恢复**。

#### 8. 预防死锁为什么不能破坏互斥条件？
1. **不可共享的资源**必须要确保互斥（如打印机）。
2. 可共享的资源**不要求互斥访问**（如只读文件）。

#### 9. 预防死锁怎么破坏占有并请求条件？
1. 确保当一个进程请求一个资源时，它**不能占有其他资源**。实现方法如下：
   - 每个进程在执行前**申请并获得所有资源**。
   - 进程只有在不占用资源时，允许进程申请资源（**申请一个，放弃一个，再申请下一个**）。

#### 10. 预防死锁如何破坏不可剥夺条件？
1. 如果一个进程**占有资源**并申请另一个**不能分配的资源**，其现已分配的**资源可被抢占**。
2. 如果一个进程申请一些资源：
   - 如果可用，就分配。
   - 如果不可用：
     - 检查资源是否已分配给其他**等待额外资源**的进程，如果是，则抢占。
     - 如果没有被其他进程占有，则等待。

#### 11. 预防死锁如何破坏循环等待？
1. 为每个资源类型**分配一个唯一的整数**。
2. 每个进程按**递增顺序申请**资源。

#### 12. 避免死锁定义
**避免死锁**指的是确保系统**不进入不安全状态**。

#### 13. 避免死锁算法的判断依据
**避免死锁**是**动态**的方法，根据进程申请资源的**附加信息**决定**是否允许**申请资源。

#### 14. 避免死锁算法使用条件
1. **资源分配图算法**：适用于每个资源类型具有**单个实例**时。
2. **银行家算法**：适用于每个资源类型具有**多个实例**时。

#### 15. 资源分配图算法规则
只有在将**申请边变成分配边**，而**不会导致**资源分配图**形成环**时，才允许申请资源。

#### 16. 银行家算法规则
1. 当新的进程进入系统时，其可能需要的每种类型资源实例的**最大数量**不能超过**系统能分配的资源总量**。
2. 当用户申请一组资源时，系统必须确定这些资源的分配**是否仍会使系统处于安全状态**。所需数据包括：
   - 进程个数。
   - 资源类型的种类。
   - 每个资源的现有实例数量。
   - 每个进程的资源需求。
   - 已分配的各种资源类型的实例数量。
   - 每个进程可能仍需要的资源数量。

#### 17. 银行家算法数据结构
1. **n**: 表示**进程数量**。
2. **m**: 表示**资源类型的数量**。
3. **Available (vector 向量)**: 表示**可分配的资源数**。
   - Available[j] = k 表示资源 Rj 的可用资源数是 k个。
4. **Max（n x m 矩阵）**: 表示**资源最大需求数**。
   - Max[i,j] = k 表示进程 Pi 可能请求的资源 Rj 的实例个数是 k。
5. **Allocation（n x m 矩阵）**: 表示**占有的资源数**。
   - Allocation[i,j] = k 表示 Pi 已占有的资源 Rj 实例的个数是 k。
6. **Need（n x m 矩阵）**: 表示完成任务**可能仍需要的资源**。
   - Need[i, j] = k 表示进程 Pi 可能需要的资源 Rj 实例数是 k。

#### 18. 银行家算法组成部分
1. **安全性算法**：确定计算机系统是否**处于安全状态**。
2. **资源请求算法**：判断是否**可安全允许请求**的算法。

#### 19. 安全性算法步骤
1. **初始化**向量：
   - Work = Available。
   - Finish[i] = false for i = 0, 1, …, n-1。
2. **查找**满足以下条件的进程 i：
   - Finish[i] = false。
   - Need[i] ≤ Work。
   如果没有满足条件的进程，跳转到步骤4。
3. **更新**状态：
   - Work = Work + Allocation[i]。
   - Finish[i] = true。
   返回步骤2。
4. **检查**：
   - 如果对所有 i，Finish[i] == true，系统处于安全状态。
   - 否则，系统处于不安全状态。

#### 19.5. 安全性算法代码

```pseudocode
Work = Available;                       // 初始化可用资源数量
For all *i*, Finish[i] = false;         // 初始化所有进程的完成状态

For all *i* do                          // 遍历所有进程
    IF (Finish[i] == false && Need[i] <= Work) // 检查进程是否满足分配条件
        Work = Work + Allocation[i];    // 更新可用资源数量
        Finish[i] = true;               // 设置当前进程为完成状态
    End IF
End For

IF for all *i*, Finish[i] == true       // 如果所有进程均完成
    Then the system is safe             // 系统处于安全状态
End IF

```

#### 20. 资源请求算法步骤
1. 如果 Request[i] ≤ Need[i]，继续。
2. 如果 Request[i] ≤ Available：
   - 修改状态：
     - Available = Available - Request[i]。
     - Allocation[i] = Allocation[i] + Request[i]。
     - Need[i] = Need[i] - Request[i]。
   - 如果**状态安全**，则分配资源。
   - 如果**状态不安全**，恢复原状态，进程 Pi 必须等待。

#### 20.5. 资源请求算法代码

```pseudocode
IF (Request[i] <= Need[i])              // 检查请求是否合法
    IF (Request[i] <= Available[i])     // 检查可用资源是否满足请求
        Available[i] = Available[i] - Request[i];  // 更新可用资源数量
        Allocation[i] = Allocation[i] + Request[i]; // 更新分配的资源
        Need[i] = Need[i] - Request[i]; // 更新需求资源数量
        do Safety Check Algorithm;      // 调用安全性检查算法
    ELSE
        waiting;                        // 如果资源不足，进程等待
    End IF
ELSE
    error message;                      // 如果请求非法，输出错误信息
End IF
```

#### 21. 死锁检测与恢复算法
1. **检测算法**：确定系统**是否进入死锁**。
2. **恢复算法**：从死锁状态中**恢复**。

#### 22. 检测算法与恢复算法的使用条件
1. 每个资源类型有**单个实例**：使用**等待图**。
2. 每个资源类型有**多个实例**：使用**对应的检测算法**。

#### 22.5. 检测算法代码

```pseudocode
Work = Available;                       // 初始化可用资源数量

For all *i* do                          // 遍历所有进程
    IF Allocation[i] ≠ 0                // 如果进程分配了资源
        Finish[i] = false;              // 标记为未完成
    ELSE
        Finish[i] = true;               // 否则标记为完成
    End IF
End For

For all *i* do                          // 再次遍历所有进程
    IF Finish[i] == false && Request[i] ≤ Work // 检查是否满足分配条件
        Work = Work + Allocation[i];    // 更新可用资源数量
        Finish[i] = true;               // 标记进程为完成状态
    End IF

    If there is a *i*, Finish[i] == false // 如果存在未完成的进程
        then the system is deadlock;    // 系统进入死锁状态
End For
```

#### 23. 死锁检测算法使用频率
1. 每次**资源请求时**调用检测算法。
2. 每次**资源请求不被允许时**调用检测算法。

#### 24. 死锁恢复算法分类
1. **进程**终止。
2. **资源**抢占。

#### 25. 进程中止方法分类
1. **终止所有**死锁进程。
2. **一次只终止一个**进程，直到取消死锁循环为止。

#### 26. 如何选择中止进程的优先级依据？
1. 进程的**优先级**。
2. 进程**已运行时**间和**完成任务所需**时间。
3. 进程**使用了多少类型**的资源。
4. 进程完成任务**需要的资源数量**。
5. 终止进程需要**释放的资源数量**。
6. 进程**类型**（交互或批处理）。

#### 27. 资源抢占定义
通过**抢占资源**以取消死锁，逐步从进程中抢占资源**给其他进程使用**，直到死锁被打破。

#### 28. 资源抢占内容
1. **选择牺牲品**：**抢占哪些资源**和哪个进程。
   - 需避免**饥饿**，即避免**同一个进程总是被抢占**。
2. **回滚 (Rollback)**：将无法正常运行的进程**回滚到某个安全状态**，以便重启进程。

