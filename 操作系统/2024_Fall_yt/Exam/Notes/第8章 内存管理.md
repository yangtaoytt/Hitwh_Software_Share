### 第8章 内存管理

[TOC]

#### 1. C语言编译命令

**Preprocessing**
```bash
$ gcc –E –o hello.i hello.c
$ cpp hello.c hello.i
```

**Compile**
```bash
$ gcc –S –o hello.s hello.c
$ cc –S hello.i
```

**Assembling**
```bash
$ gcc –c -o hello.o hello.c
$ as –o hello.o hello.s
```

**Linking**
```bash
$ gcc -o hello hello.c
$ ld hello.o
```

#### 2. 什么是CPU可以直接访问的存储器？
**内存和寄存器**是CPU唯一能直接访问的存储器。

#### 3. 如何确保进程访问地址合法？
为确保进程**只访问合法地址范围**，一个进程使用的**内存地址范围**由以下两者定义：
1. **基地址**寄存器 (base register)
2. **界限地址**寄存器 (limit register)

#### 4. 保护内存需要保护哪两个方面？
1. 保护**系统区域**不被**用户进程**访问。
2. 保护**用户进程**不被**其他进程**访问。

#### 5. 什么是地址绑定？
地址绑定是**逻辑地址**到**物理地址**的映射。

#### 6. 逻辑地址和物理地址分别是什么？
1. **逻辑地址**
   - 也叫**相对地址**，用户程序在经过编译后形成的目标代码，其首地址一般为0，其余指令中的地址都是相对于**首地址**来编址。
   - **不能**用逻辑地址直接寻址。
2. **物理地址**
   - 也叫**内存地址**或**绝对地址**，把内存分成很多个大小相等的存储单元，每个单元有一个编号，这个编号称为物理地址。
   - 物理地址**可以**直接寻址。

#### 7. 重定位是什么？
重定位是目标程序载入内存时，对目标程序中的**指令和数据地址**修改的过程（**逻辑地址**变换成**物理地址**）。

#### 8. 简述地址绑定过程？
1. 编译器将**符号地址**绑定成**可重定位地址**。
2. 链接程序和加载程序将这些**可重定位地址**绑定成**绝对地址**。

#### 9. 地址绑定到内存地址的三种情况？
1. **编译时**：编译时就知道进程将驻留内存地址。
2. **加载时**：编译时并不知道进程驻留地址，编译器必须生成**可重定位代码**。最后**绑定**延迟到加载时进行。
3. **执行时**：如果进程在执行时可以从一个内存段移到另一个内存段，绑定必须延迟到**执行时**进行。

#### 10. MMU是什么？
MMU是映射**逻辑地址**为**物理地址**的硬件设备。
- 用户进程生成的地址在送交内存之前，都会加上**重定位寄存器**的值。
- 用户程序**看不到**真正的物理地址。

#### 11. 什么是动态加载？
直到被调用之前，程序不会被载入到内存，即**加载延迟到运行时**（如 `exec("/bin/ls")` 系统调用）。

#### 12. 动态加载的优点？
1. **内存使用率**高：不使用的程序不会载入到内存。
2. 适合用**大量代码**来操作**不常发生的事件**。
3. 不需要操作系统的特别支持，由**程序员设计**。

#### 13. 静态链接和动态链接的区别？
1. **静态链接**：加载程序将库的内容**合并到二进制程序镜像**中，一直驻留在内存。
2. **动态链接**：链接延迟到**运行时（装入时）**。

#### 14. 存根的作用是什么？
存根 (stub) 用来定位适当的**内存驻留库程序**，或者在程序不在内存时装入库。

#### 15. 存根的工作过程？
1. 存根首先检查**所需子程序**是否在内存中。
2. 如果不在，则将子程序**装入内存**。
3. 存根用**子程序地址替换自己**，并开始子程序。

#### 16. 动态链接的适用范围？
动态链接通常适用于**系统库**（如语言库），由**操作系统**管理。

#### 17. 动态链接与动态加载的联系和区别？
- 动态链接和动态加载都是**在需要时加载到内存**。
- **动态链接**：程序启动时建立链接，由**操作系统**决定何时载入内存。
- **动态加载**：通过程序的方法控制加载，由**程序员**决定。

#### 18. 三种链接的C语言编译指令？
1. **常规编译**
   ```bash
   $ gcc -o main main.o bill.o fred.o
   ```
2. **静态链接**
   ```bash
   $ gcc -o slmain main.o libfoo.a
   ```
3. **动态链接**
   ```bash
   $ gcc -o dlmain main.c -L ./ -ltest
   ```

#### 19. 交换的概念？
进程可以暂时从**内存中**交换到**备份存储**（通常是快速磁盘），当需要再次执行时**再调回内存**。

#### 20. 举例一种交换算法？
优先级调度算法：**低优先级**交换出，**高优先级**交换进。

#### 21. 交换时间的影响因素？
交换时间（转移时间）与**交换内存空间量**成正比。

#### 22. 交换出的进程调回时，应调回到哪个内存空间？
1. **编译时绑定**
2. **加载时绑定**
3. **执行时绑定**

#### 23. 内存分配方式？
1. 连续分配
   - 多分区分配
   - 可变分区分配
2. 分页分配
3. 分段分配

#### 24. 多分区是什么？
多分区方法是将内存分成多个**固定大小**的分区。

#### 25. 多分区的分类？
1. **分区大小相同**：适合于多个**相同程序的并发执行**。
2. **分区大小不同**：分配适当大小的分区以**提高灵活性**。

#### 26. 分区状态表的作用？
记录**已分配孔**和**未分配孔**的信息。

#### 27. 三种动态分区分配算法？
1. **首次适应**（First Fit）：分配足够运行进程的**第一个**空闲孔。
2. **最佳适应**（Best Fit）：分配足够运行进程的**最小**空闲孔。
3. **最差适应**（Worst Fit）：分配**最大**的空闲孔。

#### 28. 外部碎片和内部碎片的定义？
1. **外部碎片**：进程分配内存区外产生的碎片。
2. **内部碎片**：进程分配内存区内产生的碎片。

#### 29. 外部碎片的解决办法？
通过**紧缩**（compaction）移动内存内容，把所有**空闲空间合并**成一整块（适用于**动态重定位**）。

#### 30. 页和帧是什么？
- **帧**：**物理内存**划分为固定大小的块，称为帧。
- **页**：**逻辑内存**划分为固定大小的块，称为页。

#### 31. 页和帧的联系？
一个页对应一个帧。若程序大小为 n 页，则需要 n 个帧来存放，这些帧不必连续。

#### 32. 逻辑地址的组成？
逻辑地址分为两个部分：**页号**和**页偏移**。

#### 33. 页表存放位置？
1. 专用**寄存器**
2. **内存**中（需要**页表基寄存器**和**页表长寄存器**）。

#### 34. 页表存放在内存的问题？
需要两次内存访问（**查页表**和**访问地址**），导致访问速度变慢。

#### 35. 解决办法？
通过**地址转换旁观缓冲**（Translation Look-aside Buffer, TLB）。

#### 36. 块表比页表多了什么？
逻辑页号。

#### 37. 分页如何实现内存保护？
与每个帧关联一个保护位，并在页表中设置有效/无效位：
1. 有效位（v）：表示相关页**在逻辑地址空间内**（合法）。
2. 无效位（i）：表示相关页**不在逻辑地址空间内**（非法）。

#### 38. 分页的优点？
通过**共享页**实现代码共享。代码可分为**可共享**和**不可共享**代码。

#### 39.两种代码地址对比？
1. 可共享的代码即**可重入代码**，每个进程共享代码段的(页)**逻辑地址相同**。
2. 不可共享的代码即**私有代码和数据**，针对私有代码和数据的(页)**逻辑地址不同**。

#### 40. 页表的实现方式？
1. 层次页表
2. 哈希页表
3. 反向页表

#### 41. 层次页表的优点？
1. 实现页表的**不连续存储**。
2. **节约内存**空间。

#### 42. 哈希页表如何工作？
通过**逻辑页号**作为哈希值来找到匹配条目，并在链表中找到相应帧号。

#### 43. 反向页表的目的？
**减少**页表消耗的**内存空间**。

#### 44. 反向页表的列组成？
1. 物理块号
2. 进程PID
3. 进程逻辑页号

#### 45. 逻辑地址的定义？
**分段号**和**偏移**。

#### 46. 段表的列包括？
**段长**和**段首物理地址**。